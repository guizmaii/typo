/**
 * File has been automatically generated by `typo` for internal use.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 *
 * (If you're developing `typo` and want to change it: run `bleep generate-sources`)
 */
package typo
package generated
package pg_catalog
package pg_type

import anorm.NamedParameter
import anorm.ParameterValue
import anorm.RowParser
import anorm.SqlStringInterpolation
import anorm.Success
import anorm.ToSql
import anorm.ToStatement
import java.sql.Connection
import java.sql.PreparedStatement
import org.postgresql.util.PGobject

object PgTypeRepoImpl extends PgTypeRepo {
  override def delete(oid: PgTypeId)(implicit c: Connection): Boolean = {
    SQL"delete from pg_catalog.pg_type where oid = $oid".executeUpdate() > 0
  }
  override def insert(oid: PgTypeId, unsaved: PgTypeRowUnsaved)(implicit c: Connection): PgTypeRow = {
    SQL"""insert into pg_catalog.pg_type(oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl)
          values (${oid}::oid, ${unsaved.typname}::name, ${unsaved.typnamespace}::oid, ${unsaved.typowner}::oid, ${unsaved.typlen}::int2, ${unsaved.typbyval}, ${unsaved.typtype}::char, ${unsaved.typcategory}::char, ${unsaved.typispreferred}, ${unsaved.typisdefined}, ${unsaved.typdelim}::char, ${unsaved.typrelid}::oid, ${unsaved.typsubscript}::regproc, ${unsaved.typelem}::oid, ${unsaved.typarray}::oid, ${unsaved.typinput}::regproc, ${unsaved.typoutput}::regproc, ${unsaved.typreceive}::regproc, ${unsaved.typsend}::regproc, ${unsaved.typmodin}::regproc, ${unsaved.typmodout}::regproc, ${unsaved.typanalyze}::regproc, ${unsaved.typalign}::char, ${unsaved.typstorage}::char, ${unsaved.typnotnull}, ${unsaved.typbasetype}::oid, ${unsaved.typtypmod}::int4, ${unsaved.typndims}::int4, ${unsaved.typcollation}::oid, ${unsaved.typdefaultbin}::pg_node_tree, ${unsaved.typdefault}, ${unsaved.typacl}::_aclitem)
          returning oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl
       """
      .executeInsert(rowParser.single)
  
  }
  override def selectAll(implicit c: Connection): List[PgTypeRow] = {
    SQL"""select oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl
          from pg_catalog.pg_type
       """.as(rowParser.*)
  }
  override def selectByFieldValues(fieldValues: List[PgTypeFieldOrIdValue[_]])(implicit c: Connection): List[PgTypeRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PgTypeFieldValue.oid(value) => NamedParameter("oid", ParameterValue.from(value))
          case PgTypeFieldValue.typname(value) => NamedParameter("typname", ParameterValue.from(value))
          case PgTypeFieldValue.typnamespace(value) => NamedParameter("typnamespace", ParameterValue.from(value))
          case PgTypeFieldValue.typowner(value) => NamedParameter("typowner", ParameterValue.from(value))
          case PgTypeFieldValue.typlen(value) => NamedParameter("typlen", ParameterValue.from(value))
          case PgTypeFieldValue.typbyval(value) => NamedParameter("typbyval", ParameterValue.from(value))
          case PgTypeFieldValue.typtype(value) => NamedParameter("typtype", ParameterValue.from(value))
          case PgTypeFieldValue.typcategory(value) => NamedParameter("typcategory", ParameterValue.from(value))
          case PgTypeFieldValue.typispreferred(value) => NamedParameter("typispreferred", ParameterValue.from(value))
          case PgTypeFieldValue.typisdefined(value) => NamedParameter("typisdefined", ParameterValue.from(value))
          case PgTypeFieldValue.typdelim(value) => NamedParameter("typdelim", ParameterValue.from(value))
          case PgTypeFieldValue.typrelid(value) => NamedParameter("typrelid", ParameterValue.from(value))
          case PgTypeFieldValue.typsubscript(value) => NamedParameter("typsubscript", ParameterValue.from(value))
          case PgTypeFieldValue.typelem(value) => NamedParameter("typelem", ParameterValue.from(value))
          case PgTypeFieldValue.typarray(value) => NamedParameter("typarray", ParameterValue.from(value))
          case PgTypeFieldValue.typinput(value) => NamedParameter("typinput", ParameterValue.from(value))
          case PgTypeFieldValue.typoutput(value) => NamedParameter("typoutput", ParameterValue.from(value))
          case PgTypeFieldValue.typreceive(value) => NamedParameter("typreceive", ParameterValue.from(value))
          case PgTypeFieldValue.typsend(value) => NamedParameter("typsend", ParameterValue.from(value))
          case PgTypeFieldValue.typmodin(value) => NamedParameter("typmodin", ParameterValue.from(value))
          case PgTypeFieldValue.typmodout(value) => NamedParameter("typmodout", ParameterValue.from(value))
          case PgTypeFieldValue.typanalyze(value) => NamedParameter("typanalyze", ParameterValue.from(value))
          case PgTypeFieldValue.typalign(value) => NamedParameter("typalign", ParameterValue.from(value))
          case PgTypeFieldValue.typstorage(value) => NamedParameter("typstorage", ParameterValue.from(value))
          case PgTypeFieldValue.typnotnull(value) => NamedParameter("typnotnull", ParameterValue.from(value))
          case PgTypeFieldValue.typbasetype(value) => NamedParameter("typbasetype", ParameterValue.from(value))
          case PgTypeFieldValue.typtypmod(value) => NamedParameter("typtypmod", ParameterValue.from(value))
          case PgTypeFieldValue.typndims(value) => NamedParameter("typndims", ParameterValue.from(value))
          case PgTypeFieldValue.typcollation(value) => NamedParameter("typcollation", ParameterValue.from(value))
          case PgTypeFieldValue.typdefaultbin(value) => NamedParameter("typdefaultbin", ParameterValue.from(value))
          case PgTypeFieldValue.typdefault(value) => NamedParameter("typdefault", ParameterValue.from(value))
          case PgTypeFieldValue.typacl(value) => NamedParameter("typacl", ParameterValue.from(value))
        }
        val q = s"""select oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl
                    from pg_catalog.pg_type
                    where ${namedParams.map(x => s"${x.name} = {${x.name}}").mkString(" AND ")}
                 """
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .as(rowParser.*)
    }
  
  }
  override def selectById(oid: PgTypeId)(implicit c: Connection): Option[PgTypeRow] = {
    SQL"""select oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl
          from pg_catalog.pg_type
          where oid = $oid
       """.as(rowParser.singleOpt)
  }
  override def selectByIds(oids: Array[PgTypeId])(implicit c: Connection): List[PgTypeRow] = {
    implicit val arrayToSql: ToSql[Array[PgTypeId]] = _ => ("?", 1) // fix wrong instance from anorm
    implicit val toStatement: ToStatement[Array[PgTypeId]] =
      (s: PreparedStatement, index: Int, v: Array[PgTypeId]) =>
        s.setArray(index, s.getConnection.createArrayOf("oid", v.map(x => x.value: java.lang.Long)))
    
    SQL"""select oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typsubscript, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl
          from pg_catalog.pg_type
          where oid = ANY($oids)
       """.as(rowParser.*)
  
  }
  override def selectByUnique(typname: String, typnamespace: /* oid */ Long)(implicit c: Connection): Option[PgTypeRow] = {
    selectByFieldValues(List(PgTypeFieldValue.typname(typname), PgTypeFieldValue.typnamespace(typnamespace))).headOption
  }
  override def update(row: PgTypeRow)(implicit c: Connection): Boolean = {
    val oid = row.oid
    SQL"""update pg_catalog.pg_type
          set typname = ${row.typname},
              typnamespace = ${row.typnamespace},
              typowner = ${row.typowner},
              typlen = ${row.typlen},
              typbyval = ${row.typbyval},
              typtype = ${row.typtype},
              typcategory = ${row.typcategory},
              typispreferred = ${row.typispreferred},
              typisdefined = ${row.typisdefined},
              typdelim = ${row.typdelim},
              typrelid = ${row.typrelid},
              typsubscript = ${row.typsubscript},
              typelem = ${row.typelem},
              typarray = ${row.typarray},
              typinput = ${row.typinput},
              typoutput = ${row.typoutput},
              typreceive = ${row.typreceive},
              typsend = ${row.typsend},
              typmodin = ${row.typmodin},
              typmodout = ${row.typmodout},
              typanalyze = ${row.typanalyze},
              typalign = ${row.typalign},
              typstorage = ${row.typstorage},
              typnotnull = ${row.typnotnull},
              typbasetype = ${row.typbasetype},
              typtypmod = ${row.typtypmod},
              typndims = ${row.typndims},
              typcollation = ${row.typcollation},
              typdefaultbin = ${row.typdefaultbin},
              typdefault = ${row.typdefault},
              typacl = ${row.typacl}
          where oid = $oid
       """.executeUpdate() > 0
  }
  override def updateFieldValues(oid: PgTypeId, fieldValues: List[PgTypeFieldValue[_]])(implicit c: Connection): Boolean = {
    fieldValues match {
      case Nil => false
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PgTypeFieldValue.typname(value) => NamedParameter("typname", ParameterValue.from(value))
          case PgTypeFieldValue.typnamespace(value) => NamedParameter("typnamespace", ParameterValue.from(value))
          case PgTypeFieldValue.typowner(value) => NamedParameter("typowner", ParameterValue.from(value))
          case PgTypeFieldValue.typlen(value) => NamedParameter("typlen", ParameterValue.from(value))
          case PgTypeFieldValue.typbyval(value) => NamedParameter("typbyval", ParameterValue.from(value))
          case PgTypeFieldValue.typtype(value) => NamedParameter("typtype", ParameterValue.from(value))
          case PgTypeFieldValue.typcategory(value) => NamedParameter("typcategory", ParameterValue.from(value))
          case PgTypeFieldValue.typispreferred(value) => NamedParameter("typispreferred", ParameterValue.from(value))
          case PgTypeFieldValue.typisdefined(value) => NamedParameter("typisdefined", ParameterValue.from(value))
          case PgTypeFieldValue.typdelim(value) => NamedParameter("typdelim", ParameterValue.from(value))
          case PgTypeFieldValue.typrelid(value) => NamedParameter("typrelid", ParameterValue.from(value))
          case PgTypeFieldValue.typsubscript(value) => NamedParameter("typsubscript", ParameterValue.from(value))
          case PgTypeFieldValue.typelem(value) => NamedParameter("typelem", ParameterValue.from(value))
          case PgTypeFieldValue.typarray(value) => NamedParameter("typarray", ParameterValue.from(value))
          case PgTypeFieldValue.typinput(value) => NamedParameter("typinput", ParameterValue.from(value))
          case PgTypeFieldValue.typoutput(value) => NamedParameter("typoutput", ParameterValue.from(value))
          case PgTypeFieldValue.typreceive(value) => NamedParameter("typreceive", ParameterValue.from(value))
          case PgTypeFieldValue.typsend(value) => NamedParameter("typsend", ParameterValue.from(value))
          case PgTypeFieldValue.typmodin(value) => NamedParameter("typmodin", ParameterValue.from(value))
          case PgTypeFieldValue.typmodout(value) => NamedParameter("typmodout", ParameterValue.from(value))
          case PgTypeFieldValue.typanalyze(value) => NamedParameter("typanalyze", ParameterValue.from(value))
          case PgTypeFieldValue.typalign(value) => NamedParameter("typalign", ParameterValue.from(value))
          case PgTypeFieldValue.typstorage(value) => NamedParameter("typstorage", ParameterValue.from(value))
          case PgTypeFieldValue.typnotnull(value) => NamedParameter("typnotnull", ParameterValue.from(value))
          case PgTypeFieldValue.typbasetype(value) => NamedParameter("typbasetype", ParameterValue.from(value))
          case PgTypeFieldValue.typtypmod(value) => NamedParameter("typtypmod", ParameterValue.from(value))
          case PgTypeFieldValue.typndims(value) => NamedParameter("typndims", ParameterValue.from(value))
          case PgTypeFieldValue.typcollation(value) => NamedParameter("typcollation", ParameterValue.from(value))
          case PgTypeFieldValue.typdefaultbin(value) => NamedParameter("typdefaultbin", ParameterValue.from(value))
          case PgTypeFieldValue.typdefault(value) => NamedParameter("typdefault", ParameterValue.from(value))
          case PgTypeFieldValue.typacl(value) => NamedParameter("typacl", ParameterValue.from(value))
        }
        val q = s"""update pg_catalog.pg_type
                    set ${namedParams.map(x => s"\"${x.name}\" = {${x.name}}").mkString(", ")}
                    where oid = {oid}
                 """
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .on(NamedParameter("oid", ParameterValue.from(oid)))
          .executeUpdate() > 0
    }
  
  }
  val rowParser: RowParser[PgTypeRow] =
    RowParser[PgTypeRow] { row =>
      Success(
        PgTypeRow(
          oid = row[PgTypeId]("oid"),
          typname = row[String]("typname"),
          typnamespace = row[/* oid */ Long]("typnamespace"),
          typowner = row[/* oid */ Long]("typowner"),
          typlen = row[Int]("typlen"),
          typbyval = row[Boolean]("typbyval"),
          typtype = row[String]("typtype"),
          typcategory = row[String]("typcategory"),
          typispreferred = row[Boolean]("typispreferred"),
          typisdefined = row[Boolean]("typisdefined"),
          typdelim = row[String]("typdelim"),
          typrelid = row[/* oid */ Long]("typrelid"),
          typsubscript = row[/* regproc */ PGobject]("typsubscript"),
          typelem = row[/* oid */ Long]("typelem"),
          typarray = row[/* oid */ Long]("typarray"),
          typinput = row[/* regproc */ PGobject]("typinput"),
          typoutput = row[/* regproc */ PGobject]("typoutput"),
          typreceive = row[/* regproc */ PGobject]("typreceive"),
          typsend = row[/* regproc */ PGobject]("typsend"),
          typmodin = row[/* regproc */ PGobject]("typmodin"),
          typmodout = row[/* regproc */ PGobject]("typmodout"),
          typanalyze = row[/* regproc */ PGobject]("typanalyze"),
          typalign = row[String]("typalign"),
          typstorage = row[String]("typstorage"),
          typnotnull = row[Boolean]("typnotnull"),
          typbasetype = row[/* oid */ Long]("typbasetype"),
          typtypmod = row[Int]("typtypmod"),
          typndims = row[Int]("typndims"),
          typcollation = row[/* oid */ Long]("typcollation"),
          typdefaultbin = row[Option[/* pg_node_tree */ PGobject]]("typdefaultbin"),
          typdefault = row[Option[String]]("typdefault"),
          typacl = row[Option[Array[/* aclitem */ PGobject]]]("typacl")
        )
      )
    }
}
