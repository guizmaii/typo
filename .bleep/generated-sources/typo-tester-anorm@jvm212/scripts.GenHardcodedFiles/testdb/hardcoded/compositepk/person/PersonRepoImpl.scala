/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb
package hardcoded
package compositepk
package person

import anorm.NamedParameter
import anorm.ParameterValue
import anorm.RowParser
import anorm.SQL
import anorm.SimpleSql
import anorm.SqlStringInterpolation
import java.sql.Connection
import testdb.hardcoded.Defaulted
import typo.dsl.DeleteBuilder
import typo.dsl.SelectBuilder
import typo.dsl.SelectBuilderSql
import typo.dsl.UpdateBuilder

object PersonRepoImpl extends PersonRepo {
  override def delete(compositeId: PersonId)(implicit c: Connection): Boolean = {
    SQL"""delete from compositepk.person where "one" = ${compositeId.one} AND two = ${compositeId.two}""".executeUpdate() > 0
  }
  override def delete: DeleteBuilder[PersonFields, PersonRow] = {
    DeleteBuilder("compositepk.person", PersonFields)
  }
  override def insert(unsaved: PersonRow)(implicit c: Connection): PersonRow = {
    SQL"""insert into compositepk.person("one", two, "name")
          values (${unsaved.one}::int8, ${unsaved.two}, ${unsaved.name})
          returning "one", two, "name"
       """
      .executeInsert(PersonRow.rowParser(1).single)
    
  }
  override def insert(unsaved: PersonRowUnsaved)(implicit c: Connection): PersonRow = {
    val namedParameters = List(
      Some((NamedParameter("name", ParameterValue.from(unsaved.name)), "")),
      unsaved.one match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((NamedParameter("one", ParameterValue.from[Long](value)), "::int8"))
      },
      unsaved.two match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((NamedParameter("two", ParameterValue.from[Option[String]](value)), ""))
      }
    ).flatten
    val quote = '"'.toString
    if (namedParameters.isEmpty) {
      SQL"""insert into compositepk.person default values
            returning "one", two, "name"
         """
        .executeInsert(PersonRow.rowParser(1).single)
    } else {
      val q = s"""insert into compositepk.person(${namedParameters.map{case (x, _) => quote + x.name + quote}.mkString(", ")})
                  values (${namedParameters.map{ case (np, cast) => s"{${np.name}}$cast"}.mkString(", ")})
                  returning "one", two, "name"
               """
      SimpleSql(SQL(q), namedParameters.map { case (np, _) => np.tupled }.toMap, RowParser.successful)
        .executeInsert(PersonRow.rowParser(1).single)
    }
    
  }
  override def select: SelectBuilder[PersonFields, PersonRow] = {
    SelectBuilderSql("compositepk.person", PersonFields, PersonRow.rowParser)
  }
  override def selectAll(implicit c: Connection): List[PersonRow] = {
    SQL"""select "one", two, "name"
          from compositepk.person
       """.as(PersonRow.rowParser(1).*)
  }
  override def selectById(compositeId: PersonId)(implicit c: Connection): Option[PersonRow] = {
    SQL"""select "one", two, "name"
          from compositepk.person
          where "one" = ${compositeId.one} AND two = ${compositeId.two}
       """.as(PersonRow.rowParser(1).singleOpt)
  }
  override def selectByFieldValues(fieldValues: List[PersonFieldOrIdValue[?]])(implicit c: Connection): List[PersonRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParameters = nonEmpty.map{
          case PersonFieldValue.one(value) => NamedParameter("one", ParameterValue.from(value))
          case PersonFieldValue.two(value) => NamedParameter("two", ParameterValue.from(value))
          case PersonFieldValue.name(value) => NamedParameter("name", ParameterValue.from(value))
        }
        val quote = '"'.toString
        val q = s"""select "one", two, "name"
                    from compositepk.person
                    where ${namedParameters.map(x => s"$quote${x.name}$quote = {${x.name}}").mkString(" AND ")}
                 """
        SimpleSql(SQL(q), namedParameters.map(_.tupled).toMap, RowParser.successful)
          .as(PersonRow.rowParser(1).*)
    }
    
  }
  override def update(row: PersonRow)(implicit c: Connection): Boolean = {
    val compositeId = row.compositeId
    SQL"""update compositepk.person
          set "name" = ${row.name}
          where "one" = ${compositeId.one} AND two = ${compositeId.two}
       """.executeUpdate() > 0
  }
  override def update: UpdateBuilder[PersonFields, PersonRow] = {
    UpdateBuilder("compositepk.person", PersonFields, PersonRow.rowParser)
  }
  override def updateFieldValues(compositeId: PersonId, fieldValues: List[PersonFieldValue[?]])(implicit c: Connection): Boolean = {
    fieldValues match {
      case Nil => false
      case nonEmpty =>
        val namedParameters = nonEmpty.map{
          case PersonFieldValue.name(value) => NamedParameter("name", ParameterValue.from(value))
        }
        val quote = '"'.toString
        val q = s"""update compositepk.person
                    set ${namedParameters.map(x => s"$quote${x.name}$quote = {${x.name}}").mkString(", ")}
                    where "one" = {one} AND two = {two}
                 """
        SimpleSql(SQL(q), namedParameters.map(_.tupled).toMap ++ List(("one", ParameterValue.from(compositeId.one)), ("two", ParameterValue.from(compositeId.two))), RowParser.successful)
          .executeUpdate() > 0
    }
    
  }
  override def upsert(unsaved: PersonRow)(implicit c: Connection): PersonRow = {
    SQL"""insert into compositepk.person("one", two, "name")
          values (
            ${unsaved.one}::int8,
            ${unsaved.two},
            ${unsaved.name}
          )
          on conflict ("one", two)
          do update set
            "name" = EXCLUDED."name"
          returning "one", two, "name"
       """
      .executeInsert(PersonRow.rowParser(1).single)
    
  }
}
