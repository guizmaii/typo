/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package purchasing
package purchaseorderheader

import adventureworks.Defaulted
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.purchasing.shipmethod.ShipmethodId
import anorm.NamedParameter
import anorm.ParameterValue
import anorm.RowParser
import anorm.SqlParser
import anorm.SqlStringInterpolation
import anorm.Success
import anorm.ToSql
import anorm.ToStatement
import java.lang.Integer
import java.sql.Connection
import java.sql.PreparedStatement
import java.time.LocalDateTime

object PurchaseorderheaderRepoImpl extends PurchaseorderheaderRepo {
  override def delete(purchaseorderid: PurchaseorderheaderId)(implicit c: Connection): Boolean = {
    SQL"""delete from purchasing.purchaseorderheader where purchaseorderid = $purchaseorderid""".executeUpdate() > 0
  }
  override def insert(unsaved: PurchaseorderheaderRowUnsaved)(implicit c: Connection): PurchaseorderheaderId = {
    val namedParameters = List(
      unsaved.revisionnumber match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("revisionnumber", ParameterValue.from[Int](value)))
      },
      unsaved.status match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("status", ParameterValue.from[Int](value)))
      },
      Some(NamedParameter("employeeid", ParameterValue.from(unsaved.employeeid))),
      Some(NamedParameter("vendorid", ParameterValue.from(unsaved.vendorid))),
      Some(NamedParameter("shipmethodid", ParameterValue.from(unsaved.shipmethodid))),
      unsaved.orderdate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("orderdate", ParameterValue.from[LocalDateTime](value)))
      },
      Some(NamedParameter("shipdate", ParameterValue.from(unsaved.shipdate))),
      unsaved.subtotal match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("subtotal", ParameterValue.from[BigDecimal](value)))
      },
      unsaved.taxamt match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("taxamt", ParameterValue.from[BigDecimal](value)))
      },
      unsaved.freight match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("freight", ParameterValue.from[BigDecimal](value)))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some(NamedParameter("modifieddate", ParameterValue.from[LocalDateTime](value)))
      }
    ).flatten
    
    SQL"""insert into purchasing.purchaseorderheader(${namedParameters.map(_.name).mkString(", ")})
          values (${namedParameters.map(np => s"{${np.name}}").mkString(", ")})
          returning purchaseorderid
    """
      .on(namedParameters :_*)
      .executeInsert(idRowParser.single)
  
  }
  override def selectAll(implicit c: Connection): List[PurchaseorderheaderRow] = {
    SQL"""select purchaseorderid, revisionnumber, status, employeeid, vendorid, shipmethodid, orderdate, shipdate, subtotal, taxamt, freight, modifieddate from purchasing.purchaseorderheader""".as(rowParser.*)
  }
  override def selectByFieldValues(fieldValues: List[PurchaseorderheaderFieldOrIdValue[_]])(implicit c: Connection): List[PurchaseorderheaderRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PurchaseorderheaderFieldValue.purchaseorderid(value) => NamedParameter("purchaseorderid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.revisionnumber(value) => NamedParameter("revisionnumber", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.status(value) => NamedParameter("status", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.employeeid(value) => NamedParameter("employeeid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.vendorid(value) => NamedParameter("vendorid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.shipmethodid(value) => NamedParameter("shipmethodid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.orderdate(value) => NamedParameter("orderdate", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.shipdate(value) => NamedParameter("shipdate", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.subtotal(value) => NamedParameter("subtotal", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.taxamt(value) => NamedParameter("taxamt", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.freight(value) => NamedParameter("freight", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.modifieddate(value) => NamedParameter("modifieddate", ParameterValue.from(value))
        }
        val q = s"""select * from purchasing.purchaseorderheader where ${namedParams.map(x => s"${x.name} = {${x.name}}").mkString(" AND ")}"""
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .as(rowParser.*)
    }
  
  }
  override def selectById(purchaseorderid: PurchaseorderheaderId)(implicit c: Connection): Option[PurchaseorderheaderRow] = {
    SQL"""select purchaseorderid, revisionnumber, status, employeeid, vendorid, shipmethodid, orderdate, shipdate, subtotal, taxamt, freight, modifieddate from purchasing.purchaseorderheader where purchaseorderid = $purchaseorderid""".as(rowParser.singleOpt)
  }
  override def selectByIds(purchaseorderids: Array[PurchaseorderheaderId])(implicit c: Connection): List[PurchaseorderheaderRow] = {
    implicit val arrayToSql: ToSql[Array[PurchaseorderheaderId]] = _ => ("?", 1) // fix wrong instance from anorm
    implicit val toStatement: ToStatement[Array[PurchaseorderheaderId]] =
      (s: PreparedStatement, index: Int, v: Array[PurchaseorderheaderId]) =>
        s.setArray(index, s.getConnection.createArrayOf("int4", v.map(x => x.value: Integer)))
    
    SQL"""select purchaseorderid, revisionnumber, status, employeeid, vendorid, shipmethodid, orderdate, shipdate, subtotal, taxamt, freight, modifieddate from purchasing.purchaseorderheader where purchaseorderid = ANY($purchaseorderids)""".as(rowParser.*)
  
  }
  override def update(row: PurchaseorderheaderRow)(implicit c: Connection): Boolean = {
    val purchaseorderid = row.purchaseorderid
    SQL"""update purchasing.purchaseorderheader
          set revisionnumber = ${row.revisionnumber},
              status = ${row.status},
              employeeid = ${row.employeeid},
              vendorid = ${row.vendorid},
              shipmethodid = ${row.shipmethodid},
              orderdate = ${row.orderdate},
              shipdate = ${row.shipdate},
              subtotal = ${row.subtotal},
              taxamt = ${row.taxamt},
              freight = ${row.freight},
              modifieddate = ${row.modifieddate}
          where purchaseorderid = $purchaseorderid""".executeUpdate() > 0
  }
  override def updateFieldValues(purchaseorderid: PurchaseorderheaderId, fieldValues: List[PurchaseorderheaderFieldValue[_]])(implicit c: Connection): Boolean = {
    fieldValues match {
      case Nil => false
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PurchaseorderheaderFieldValue.revisionnumber(value) => NamedParameter("revisionnumber", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.status(value) => NamedParameter("status", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.employeeid(value) => NamedParameter("employeeid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.vendorid(value) => NamedParameter("vendorid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.shipmethodid(value) => NamedParameter("shipmethodid", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.orderdate(value) => NamedParameter("orderdate", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.shipdate(value) => NamedParameter("shipdate", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.subtotal(value) => NamedParameter("subtotal", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.taxamt(value) => NamedParameter("taxamt", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.freight(value) => NamedParameter("freight", ParameterValue.from(value))
          case PurchaseorderheaderFieldValue.modifieddate(value) => NamedParameter("modifieddate", ParameterValue.from(value))
        }
        val q = s"""update purchasing.purchaseorderheader
                    set ${namedParams.map(x => s"${x.name} = {${x.name}}").mkString(", ")}
                    where purchaseorderid = $purchaseorderid"""
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .executeUpdate() > 0
    }
  
  }
  val rowParser: RowParser[PurchaseorderheaderRow] =
    RowParser[PurchaseorderheaderRow] { row =>
      Success(
        PurchaseorderheaderRow(
          purchaseorderid = row[PurchaseorderheaderId]("purchaseorderid"),
          revisionnumber = row[Int]("revisionnumber"),
          status = row[Int]("status"),
          employeeid = row[BusinessentityId]("employeeid"),
          vendorid = row[BusinessentityId]("vendorid"),
          shipmethodid = row[ShipmethodId]("shipmethodid"),
          orderdate = row[LocalDateTime]("orderdate"),
          shipdate = row[Option[LocalDateTime]]("shipdate"),
          subtotal = row[BigDecimal]("subtotal"),
          taxamt = row[BigDecimal]("taxamt"),
          freight = row[BigDecimal]("freight"),
          modifieddate = row[LocalDateTime]("modifieddate")
        )
      )
    }
  val idRowParser: RowParser[PurchaseorderheaderId] =
    SqlParser.get[PurchaseorderheaderId]("purchaseorderid")
}
