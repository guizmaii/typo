/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package person
package person

import adventureworks.Defaulted.Provided
import adventureworks.Defaulted.UseDefault
import adventureworks.public.NameStyle
import anorm.NamedParameter
import anorm.ParameterValue
import anorm.SqlStringInterpolation
import java.sql.Connection
import java.time.LocalDateTime
import java.util.UUID

object PersonRepoImpl extends PersonRepo {
  override def delete(businessentityid: PersonId)(implicit c: Connection): Boolean = {
    SQL"""delete from person.person where businessentityid = $businessentityid""".executeUpdate() > 0
  }
  override def insert(businessentityid: PersonId, unsaved: PersonRowUnsaved)(implicit c: Connection): Boolean = {
    val namedParameters = List(
      Some(NamedParameter("persontype", ParameterValue.from(unsaved.persontype))),
      unsaved.namestyle match {
        case UseDefault => None
        case Provided(value) => Some(NamedParameter("namestyle", ParameterValue.from[NameStyle](value)))
      },
      Some(NamedParameter("title", ParameterValue.from(unsaved.title))),
      Some(NamedParameter("firstname", ParameterValue.from(unsaved.firstname))),
      Some(NamedParameter("middlename", ParameterValue.from(unsaved.middlename))),
      Some(NamedParameter("lastname", ParameterValue.from(unsaved.lastname))),
      Some(NamedParameter("suffix", ParameterValue.from(unsaved.suffix))),
      unsaved.emailpromotion match {
        case UseDefault => None
        case Provided(value) => Some(NamedParameter("emailpromotion", ParameterValue.from[Int](value)))
      },
      Some(NamedParameter("additionalcontactinfo", ParameterValue.from(unsaved.additionalcontactinfo))),
      Some(NamedParameter("demographics", ParameterValue.from(unsaved.demographics))),
      unsaved.rowguid match {
        case UseDefault => None
        case Provided(value) => Some(NamedParameter("rowguid", ParameterValue.from[UUID](value)))
      },
      unsaved.modifieddate match {
        case UseDefault => None
        case Provided(value) => Some(NamedParameter("modifieddate", ParameterValue.from[LocalDateTime](value)))
      }
    ).flatten
    
    SQL"""insert into person.person(businessentityid, ${namedParameters.map(_.name).mkString(", ")})
          values (${businessentityid}, ${namedParameters.map(np => s"{${np.name}}").mkString(", ")})
    """
      .on(namedParameters :_*)
      .execute()
  
  }
  override def selectAll(implicit c: Connection): List[PersonRow] = {
    SQL"""select businessentityid, persontype, namestyle, title, firstname, middlename, lastname, suffix, emailpromotion, additionalcontactinfo, demographics, rowguid, modifieddate from person.person""".as(PersonRow.rowParser("").*)
  }
  override def selectByFieldValues(fieldValues: List[PersonFieldOrIdValue[_]])(implicit c: Connection): List[PersonRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PersonFieldValue.businessentityid(value) => NamedParameter("businessentityid", ParameterValue.from(value))
          case PersonFieldValue.persontype(value) => NamedParameter("persontype", ParameterValue.from(value))
          case PersonFieldValue.namestyle(value) => NamedParameter("namestyle", ParameterValue.from(value))
          case PersonFieldValue.title(value) => NamedParameter("title", ParameterValue.from(value))
          case PersonFieldValue.firstname(value) => NamedParameter("firstname", ParameterValue.from(value))
          case PersonFieldValue.middlename(value) => NamedParameter("middlename", ParameterValue.from(value))
          case PersonFieldValue.lastname(value) => NamedParameter("lastname", ParameterValue.from(value))
          case PersonFieldValue.suffix(value) => NamedParameter("suffix", ParameterValue.from(value))
          case PersonFieldValue.emailpromotion(value) => NamedParameter("emailpromotion", ParameterValue.from(value))
          case PersonFieldValue.additionalcontactinfo(value) => NamedParameter("additionalcontactinfo", ParameterValue.from(value))
          case PersonFieldValue.demographics(value) => NamedParameter("demographics", ParameterValue.from(value))
          case PersonFieldValue.rowguid(value) => NamedParameter("rowguid", ParameterValue.from(value))
          case PersonFieldValue.modifieddate(value) => NamedParameter("modifieddate", ParameterValue.from(value))
        }
        val q = s"""select * from person.person where ${namedParams.map(x => s"${x.name} = {${x.name}}").mkString(" AND ")}"""
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .as(PersonRow.rowParser("").*)
    }
  
  }
  override def selectById(businessentityid: PersonId)(implicit c: Connection): Option[PersonRow] = {
    SQL"""select businessentityid, persontype, namestyle, title, firstname, middlename, lastname, suffix, emailpromotion, additionalcontactinfo, demographics, rowguid, modifieddate from person.person where businessentityid = $businessentityid""".as(PersonRow.rowParser("").singleOpt)
  }
  override def selectByIds(businessentityids: List[PersonId])(implicit c: Connection): List[PersonRow] = {
    SQL"""select businessentityid, persontype, namestyle, title, firstname, middlename, lastname, suffix, emailpromotion, additionalcontactinfo, demographics, rowguid, modifieddate from person.person where businessentityid in $businessentityids""".as(PersonRow.rowParser("").*)
  }
  override def update(businessentityid: PersonId, row: PersonRow)(implicit c: Connection): Boolean = {
    SQL"""update person.person
          set persontype = ${row.persontype},
              namestyle = ${row.namestyle},
              title = ${row.title},
              firstname = ${row.firstname},
              middlename = ${row.middlename},
              lastname = ${row.lastname},
              suffix = ${row.suffix},
              emailpromotion = ${row.emailpromotion},
              additionalcontactinfo = ${row.additionalcontactinfo},
              demographics = ${row.demographics},
              rowguid = ${row.rowguid},
              modifieddate = ${row.modifieddate}
          where businessentityid = $businessentityid""".executeUpdate() > 0
  }
  override def updateFieldValues(businessentityid: PersonId, fieldValues: List[PersonFieldValue[_]])(implicit c: Connection): Boolean = {
    fieldValues match {
      case Nil => false
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case PersonFieldValue.persontype(value) => NamedParameter("persontype", ParameterValue.from(value))
          case PersonFieldValue.namestyle(value) => NamedParameter("namestyle", ParameterValue.from(value))
          case PersonFieldValue.title(value) => NamedParameter("title", ParameterValue.from(value))
          case PersonFieldValue.firstname(value) => NamedParameter("firstname", ParameterValue.from(value))
          case PersonFieldValue.middlename(value) => NamedParameter("middlename", ParameterValue.from(value))
          case PersonFieldValue.lastname(value) => NamedParameter("lastname", ParameterValue.from(value))
          case PersonFieldValue.suffix(value) => NamedParameter("suffix", ParameterValue.from(value))
          case PersonFieldValue.emailpromotion(value) => NamedParameter("emailpromotion", ParameterValue.from(value))
          case PersonFieldValue.additionalcontactinfo(value) => NamedParameter("additionalcontactinfo", ParameterValue.from(value))
          case PersonFieldValue.demographics(value) => NamedParameter("demographics", ParameterValue.from(value))
          case PersonFieldValue.rowguid(value) => NamedParameter("rowguid", ParameterValue.from(value))
          case PersonFieldValue.modifieddate(value) => NamedParameter("modifieddate", ParameterValue.from(value))
        }
        val q = s"""update person.person
                    set ${namedParams.map(x => s"${x.name} = {${x.name}}").mkString(", ")}
                    where businessentityid = $businessentityid"""
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .executeUpdate() > 0
    }
  
  }
}
